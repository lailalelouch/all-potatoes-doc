For the recipes create view, I've decided to use class-based views instead of function based because when I had the whole code in one function, it was too much of a mess. On the other hand, the class-base view gave the ability to separate the code and make it more readable and maintainable. Let's see how it'll look like.

`recipes/views.py`
```python
from django.shortcuts import render, redirect
from django.views.generic import CreateView

from .models import Recipe, Category, Ingredient, Instruction
from .forms import RecipeForm, IngredientFormSet, InstructionFormSet

...

class RecipeCreateView(CreateView):
	template_name = 'create_recipe.html'
	form_class = RecipeForm
	success_url = 'recipe-details'
```

Before we go any further, I want you to try this view. So create a new template called `create_recipe.html` in the `templates`folder and display the form in it.

`recipes/templates/create_recipe.html`
```html
{{form}}
```

Then create a url for this view.

`recipes/urls.py`
```python
urlpatterns = [
    ...
    path('create/recipe/', views.RecipeCreateView.as_view(), name="recipe-create"),
]
```

Notice that in this url we added `as_view()` unlike the two other paths. The reason is that `RecipeCreateView` is a class-based view. So, for any class-based view you need to add `as_view` when setting the path for the url.

Now run the server and go to this url `127.0.0.1:8000/create/recipe/`. You should see the `RecipeForm` that we created (and not a very pretty one) without neither the ingredient nor the instruction formsets that we created. 

Now that you've seen what the output is I'll start explaining what we've done and what we need to do.

All we did was create this view
```python
class RecipeCreateView(CreateView):
	template_name = 'create_recipe.html'
	form_class = RecipeForm
	success_url = 'recipe-details'
```

This class is inheriting from [`CreateView`](http://ccbv.co.uk/projects/Django/2.2/django.views.generic.edit/CreateView/). This class has many attributes and methods that do much of the work for us and all we have to do is give it some pieces of information. In our case, we had to give it the `template_name` which is the template that it should display. We also gave it the `form_class` which is the form that we want it to display. Finally, we gave it the `success_url` which is the name of the path that we want it to redirect to after the form was successfully submitted. The cool thing is we didn't need to write most of the code that we usually do when making any create view. However, what was automagically generated by the class view isn't exactly what we want.

The most obvious change that we need to do is add both the ingredient and instruction `formset`s to the equation. So, we'll need some of the methods that `CreateView` has.

The big question is...what methods should we override?

To answer this question, we need to understand what we want to change and customize in this view.

I'll write the things that we need to change right under the dancing potato, but don't scroll down immediately. Take the time to actually think about it.

![dancing potato](https://media1.tenor.com/images/61497871ab091f01703a3f1a624fb3c4/tenor.gif?itemid=11684043)


The first thing that we want is when the user requests the recipe create page, he sees the recipe form, the ingredient formset, and the instruction formset. Right now we're only displaying the recipe form because that's the only form that is being sent through the context dictionary to the template. So, we need to send those two formsets through the context dictionary to the template to show them to the user. Take a look at this [reference](http://ccbv.co.uk/projects/Django/2.2/django.views.generic.edit/CreateView/) and look at all the available methods that we can override and guess which one we'll need to override. I'll give you a hint...When the user makes a **get** request, the three forms should be sent through the context dictionary.


If the hint wasn't hinty enough, the method is `get`.

### get()


`recipes/views.py`
```python
class RecipeCreateView(CreateView):
	template_name = 'create_recipe.html'
	form_class = RecipeForm
	success_url = 'recipe-details'

	def get(self, request, *args, **kwargs):
		self.object = None

		form = self.get_form()
		ingredient_form = IngredientFormSet()
		instruction_form = InstructionFormSet()

		return self.render_to_response(
			self.get_context_data(form=form, ingredient_form=ingredient_form, instruction_form=instruction_form)
		)

```

The change that we made is very simple. All we did is add these two formsets.
```py
		ingredient_form = IngredientFormSet()
		instruction_form = InstructionFormSet()
```

I'll explain what each line is doing in details below. If you don't really care about these details, you can skip the next few lines right until the dancing potato.

```py
	self.object = None
```

In this line we're instantiating a new attribute to our class called `object`. We're doing that because the `CreateView` expects this attribute to exist because other methods that this class is using is using this attribute. Since the recipe is still not created, the `object` attribute is set to `None` in any other case it would be set to the recipe object that we're manipulating.

```py
	form = self.get_form()
	ingredient_form = IngredientFormSet()
	instruction_form = InstructionFormSet()
```

In these three lines we're just saving our forms into variables. The only part that might be confusing is the first line. This line is equivalent to this
```py
form = RecipeForm()
```

What `self.get_form()` is doing is basically retrieving the `form_class` that we specified as an attribute in the class which in this case was `RecipeForm`. The reason we used `form = self.get_form()` instead of `form = RecipeForm()` is because I didn't want to write the form name manually everytime I want to use it in this class (this won't be the only method we're overriding). Imagine this scenario, you or one of your teammates decided to change the form name for whatever reason or you want the exact same code for another view. You will need to go through each time you wrote the form's name and change it. However, in this case you just change the `form_class` attribute. So, the `CreateView` class is giving the option to make the code better so why waste it.

Finally, we have this line
```py
	return self.render_to_response(
		self.get_context_data(form=form, ingredient_form=ingredient_form, instruction_form=instruction_form)
	)
```

This line has two methods that the `CreateView` class has. The first one is `render_to_response`. This method takes the context dictionary and renders the template specified in the `template_name` attribute with the context dictionary.

So, this line is equivelant to this
```py
return render(self.request, self.template_name,
			self.get_context_data(form=form, ingredient_form=ingredient_form, instruction_form=instruction_form)
		)
```

Now, let's take a look at the other method `get_context_data`. All this method does is take whatever arguments you give it and put them all in a dictionary.

So, this line would be equivelant to this
```py
	return render(self.request, self.template_name,{"form":form, "ingredient_form":ingredient_form, "instruction_form":instruction_form})
```

![dancing potato](https://media1.tenor.com/images/61497871ab091f01703a3f1a624fb3c4/tenor.gif?itemid=11684043)


Just for the sake of actually seeing the forms, change your template to this
`recipes/templates/create_recipe.html`
```html
{{form}}
<hr>
{{ingredient_form}}
<hr>
{{instruction_form}}
```

The next method that we need to override is the `post` method. This is where we specify what happens when the user submits the form. Right now what will happen is a recipe object will get created without any ingredients or instructions plus we need to set the owner of the recipe too.


### post()

`recipes/views.py`
```py
class RecipeCreateView(CreateView):
	template_name = 'create_recipe.html'
	form_class = RecipeForm
	success_url = 'recipe-details'

	...
	
	def post(self, request, *args, **kwargs):
		self.object = None
		form_class = self.get_form_class()
		form = form_class(request.POST, request.FILES)
		ingredient_form = IngredientFormSet(self.request.POST)
		instruction_form = InstructionFormSet(self.request.POST)
		if (form.is_valid() and ingredient_form.is_valid() and instruction_form.is_valid()):
			return self.form_valid(form, ingredient_form, instruction_form)
		else:
			return self.form_invalid(form, ingredient_form, instruction_form)
```

I'll explain what each line is doing except for any lines that we're explained before. If you're not interested in these details skip to the dancing potato.

We'll start from the second line
```py
	form_class = self.get_form_class()
	form = form_class(request.POST, request.FILES)
```

What we did here was get the `form_class`. The difference between getting the `form_class` and getting the `form` just like we did in the get method is that `get_form` returns this `RecipeForm()` and `get_form_class()` returns this `RecipeForm`. In the get we wanted a new empty form from `RecipeForm` so the first option was perfect. But in the post method we wanted an intance of `RecipeForm` to fill with the data received through the post request. So, we got the `form_class` and then used it to get a form filled with the data received from the post request.

So, those two line are equivelant to this
```py
form = RecipeForm(request.POST, request.FILES)
```

One more thing, we have both `request.POST` and `request.FILES` because the user will upload an image through the form, so we need to get the files as well.

I'll skip down to the if statement
```py
if (form.is_valid() and ingredient_form.is_valid() and instruction_form.is_valid()):
	return self.form_valid(form, ingredient_form, instruction_form)
else:
	return self.form_invalid(form, ingredient_form, instruction_form)
```

This if statement is checking if all forms are valid. If they are it'll call the `form_valid` method, otherwise the `form_invalid` method. 

So, if all forms were valid we want to save the recipe with its ingredients and instructions and then redirect to the `success_url`. Logically, this is what the `form_valid` should do.

On the other hand, if one of the forms was invalid, send the forms back to the template and show the errors to the user and that's what `form_invalid` should do.

But both of these methods are only working on the recipe form without the ingredients and instructions. So, we'll need to override those too.

Note, we could've written the code for saving the forms and the redirection here in the post method with ever mentioning or overriding the `form_valid` and `form_invalid` methods, but I like to seperate things so bear with me.


![bear](https://media.giphy.com/media/l2QDSQ8zZcc4hqUTe/giphy.gif)


### form_valid()

`recipes/views.py`
```py
class RecipeCreateView(CreateView):
	template_name = 'create_recipe.html'
	form_class = RecipeForm
	success_url = 'recipe-details'

	...
	
	def form_valid(self, form, ingredient_form, instruction_form):
		object = form.save(commit=False)
		object.owner = self.request.user
		object.save()
		ingredient_form.instance = object
		ingredient_form.save()
		instruction_form.instance = object
		instruction_form.save()
		return redirect(self.success_url, object.slug)
```

This one is pretty straight forward. 

```py
object = form.save(commit=False)
object.owner = self.request.user
object.save()
```

In the first line we're creating the recipe object without saving it to the database by setting `commit=False`. We did that because we wanted to set the `owner` first which is what we've done in the second line. Finally, we saved it to the databse.

```py
ingredient_form.instance = object
ingredient_form.save()
instruction_form.instance = object
instruction_form.save()
```

In those four lines, we're setting the `instance` for all the created ingredients and instructions. By `instance` I mean the `Recipe` object that they're related to through the `ForeignKey` relationship. And then we saved both the created ingredients and instructions to the database.

Do keep in mind that `instance` is an attribute that the `inline formset` has to make it easier for us to connect the two objects to each other (`Recipe` and `Ingredient` or `Recipe` and `Instruction`) and it is **NOT** an attribute or a field that the model has.


At the end, we're just redirecting the recipe details page where the url takes one argument which is the recipes slug.
```py
return redirect(self.success_url, object.slug)
```


### form_invalid()

`recipes/views.py`
```py
	
class RecipeCreateView(CreateView):
	template_name = 'create_recipe.html'
	form_class = RecipeForm
	success_url = 'recipe-details'

	...

	def form_invalid(self, form, ingredient_form, instruction_form):
		return self.render_to_response(
			self.get_context_data(form=form, ingredient_form=ingredient_form, instruction_form=instruction_form)
		)
```

This method is just rendering the template again because the forms were invalid.

At the end you should have this
`recipes/views.py`
```py
from django.shortcuts import render, redirect
from django.views.generic import CreateView

from .models import Recipe, Category, Ingredient, Instruction
from .forms import RecipeForm, IngredientFormSet, InstructionFormSet

...


class RecipeCreateView(CreateView):
	template_name = 'create_recipe.html'
	form_class = RecipeForm
	success_url = 'recipe-details'

	def get(self, request, *args, **kwargs):
		self.object = None

		form = self.get_form()
		ingredient_form = IngredientFormSet()
		instruction_form = InstructionFormSet()

		return self.render_to_response(self.get_context_data(form=form, ingredient_form=ingredient_form, instruction_form=instruction_form))

	def post(self, request, *args, **kwargs):
		self.object = None
		form_class = self.get_form_class()
		form = form_class(request.POST, request.FILES)
		ingredient_form = IngredientFormSet(request.POST)
		instruction_form = InstructionFormSet(request.POST)
		if (form.is_valid() and ingredient_form.is_valid() and
			instruction_form.is_valid()):
			return self.form_valid(form, ingredient_form, instruction_form)
		else:
			return self.form_invalid(form, ingredient_form, instruction_form)

	def form_valid(self, form, ingredient_form, instruction_form):
		object = form.save(commit=False)
		object.owner = self.request.user
		object.save()
		ingredient_form.instance = object
		ingredient_form.save()
		instruction_form.instance = object
		instruction_form.save()
		return redirect(self.success_url, object.slug)

	def form_invalid(self, form, ingredient_form, instruction_form):
		return self.render_to_response(
			self.get_context_data(form=form,
								  ingredient_form=ingredient_form,
								  instruction_form=instruction_form))
```

And we're finally done from this view

![phew](https://media.giphy.com/media/Oj5w7lOaR5ieNpuBhn/giphy.gif)

